#Copyright 2013 Sub Protocol and other contributors
#http://subprotocol.com/
#
#Permission is hereby granted, free of charge, to any person obtaining
#a copy of this software and associated documentation files (the
#"Software"), to deal in the Software without restriction, including
#without limitation the rights to use, copy, modify, merge, publish,
#distribute, sublicense, and/or sell copies of the Software, and to
#permit persons to whom the Software is furnished to do so, subject to
#the following conditions:
#
#The above copyright notice and this permission notice shall be
#included in all copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
#LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
#OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
#WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#VEC2
#A simple 2-dimensional vector implementation
class @Vec2
  constructor: (@x,@y) ->
    @x = x or 0
    @y = y or 0
  add: (v) ->
    new Vec2(@x + v.x, @y + v.y)
  sub: (v) ->
    new Vec2(@x - v.x, @y - v.y)
  mul: (v) ->
    new Vec2(@x * v.x, @y * v.y)
  div: (v) ->
    new Vec2(@x / v.x, @y / v.y)
  scale: (coef) ->
    new Vec2(@x * coef, @y * coef)
  mutableSet: (v) ->
    @x = v.x
    @y = v.y
    this
  mutableAdd: (v) ->
    @x += v.x
    @y += v.y
    this
  mutableSub: (v) ->
    @x -= v.x
    @y -= v.y
    this
  mutableMul: (v) ->
    @x *= v.x
    @y *= v.y
    this
  mutableDiv: (v) ->
    @x /= v.x
    @y /= v.y
    this
  mutableScale: (coef) ->
    @x *= coef
    @y *= coef
    this
  equals: (v) ->
    @x is v.x and @y is v.y
  epsilonEquals: (v, epsilon) ->
    Math.abs(@x - v.x) <= epsilon and Math.abs(@y - v.y) <= epsilon
  length: (v) ->
    Math.sqrt @x * @x + @y * @y
  length2: (v) ->
    @x * @x + @y * @y
  dist: (v) ->
    Math.sqrt @dist2(v)
  dist2: (v) ->
    x = v.x - @x
    y = v.y - @y
    x * x + y * y
  normal: ->
    m = Math.sqrt(@x * @x + @y * @y)
    new Vec2(@x / m, @y / m)
  dot: (v) ->
    @x * v.x + @y * v.y
  angle: (v) ->
    Math.atan2 @x * v.y - @y * v.x, @x * v.x + @y * v.y
  angle2: (vLeft, vRight) ->
    vLeft.sub(this).angle vRight.sub(this)
  rotate: (origin, theta) ->
    x = @x - origin.x
    y = @y - origin.y
    new Vec2(x * Math.cos(theta) - y * Math.sin(theta) + origin.x, x * Math.sin(theta) + y * Math.cos(theta) + origin.y)
  toString: ->
    "(" + @x + ", " + @y + ")"

#CONSTRAINTS
#DistanceConstraint -- constrains to initial distance
#PinConstraint -- constrains to static/fixed point
#AngleConstraint -- constrains 3 particles to an angle
class @DistanceConstraint
  constructor: (a, b, stiffness, distance) -> #optional
    @a = a
    @b = b
    @distance = (if typeof distance isnt "undefined" then distance else a.pos.sub(b.pos).length())
    @stiffness = stiffness
  relax: (stepCoef) ->
    ##log @distance
    normal = @a.pos.sub(@b.pos)
    m = normal.length2()
    normal.mutableScale ((@distance * @distance - m) / m) * @stiffness * stepCoef
    @a.pos.mutableAdd normal
    @b.pos.mutableSub normal
  draw: (ctx) ->
    ctx.beginPath()
    ctx.moveTo @a.pos.x, @a.pos.y
    ctx.lineTo @b.pos.x, @b.pos.y
    ctx.strokeStyle = "#d8dde2"
    ctx.stroke()

class @RepulsiveConstraint
  constructor: (a, b, stiffness, distance) -> #optional
    @a = a
    @b = b
    @distance = (if typeof distance isnt "undefined" then distance else a.pos.sub(b.pos).length())
    @stiffness = stiffness
  relax: (stepCoef) ->
    #log @distance
    normal = @a.pos.sub(@b.pos)
    m = normal.length2()
    normal.mutableScale ((@distance * @distance - m) / m) * @stiffness * stepCoef
    @a.pos.mutableAdd normal
    @b.pos.mutableSub normal
  draw: (ctx) ->
    ctx.beginPath()
    ctx.moveTo @a.pos.x, @a.pos.y
    ctx.lineTo @b.pos.x, @b.pos.y
    ctx.strokeStyle = "#d8dde2"
    ctx.stroke()

class @PinConstraint
  constructor: (a, pos) ->
    @a = a
    @pos = (new Vec2()).mutableSet(pos)
  relax: (stepCoef) ->
    @a.pos.mutableSet @pos
  draw: (ctx) ->
    ctx.beginPath()
    ctx.arc @pos.x, @pos.y, 6, 0, 2 * Math.PI
    ctx.fillStyle = "rgba(0,153,255,0.1)"
    ctx.fill()

class @AngleConstraint
  constructor: (a, b, c, stiffness) ->
    @a = a
    @b = b
    @c = c
    @angle = @b.pos.angle2(@a.pos, @c.pos)
    @stiffness = stiffness
  relax: (stepCoef) ->
    angle = @b.pos.angle2(@a.pos, @c.pos)
    diff = angle - @angle
    if diff <= -Math.PI
      diff += 2 * Math.PI
    else diff -= 2 * Math.PI  if diff >= Math.PI
    diff *= stepCoef * @stiffness
    @a.pos = @a.pos.rotate(@b.pos, diff)
    @c.pos = @c.pos.rotate(@b.pos, -diff)
    @b.pos = @b.pos.rotate(@a.pos, diff)
    @b.pos = @b.pos.rotate(@c.pos, -diff)
  draw: (ctx) ->
    ctx.beginPath()
    ctx.moveTo @a.pos.x, @a.pos.y
    ctx.lineTo @b.pos.x, @b.pos.y
    ctx.lineTo @c.pos.x, @c.pos.y
    tmp = ctx.lineWidth
    ctx.lineWidth = 5
    ctx.strokeStyle = "rgba(255,255,0,0.2)"
    ctx.stroke()
    ctx.lineWidth = tmp

class @Composite
  constructor: (particles, constraints, drawParticles, drawConstraints) ->
    @particles = []
    @constraints = []
    @drawParticles = null
    @drawConstraints = null
  pin: (index, pos) ->
    pos = pos or @particles[index].pos
    pc = new PinConstraint(@particles[index], pos)
    @constraints.push pc
    pc

#VERLET
class @Particle
  constructor: (pos) ->
    @pos = (new Vec2()).mutableSet(pos)
    @lastPos = (new Vec2()).mutableSet(pos)
  draw: (ctx) ->
    ctx.beginPath()
    ctx.arc @pos.x, @pos.y, 2, 0, 2 * Math.PI
    #ctx.arc 10, 10, 2, 0, 2 * Math.PI
    #ctx.arc 60, 10, 2, 0, 2 * Math.PI
    #ctx.arc 60, 110, 2, 0, 2 * Math.PI
    #ctx.arc 10, 110, 2, 0, 2 * Math.PI
    ctx.fillStyle = "#2dad8f"
    ctx.fill()
    ###ctx.closePath()

    ctx.beginPath()
    ctx.arc 5, 5, 2, 0, 2 * Math.PI
    ctx.arc 50, 5, 2, 0, 2 * Math.PI
    ctx.arc 50, 55, 2, 0, 2 * Math.PI
    ctx.arc 5, 55, 2, 0, 2 * Math.PI
    ctx.fillStyle = "#ff0000"
    ctx.fill()
    ctx.closePath()###

class @VerletJS
  constructor: (width, height, canvas) ->
    @width = width
    @height = height
    @canvas = canvas
    @ctx = canvas.getContext("2d")
    @mouse = new Vec2(0, 0)
    @mouseDown = false
    @draggedEntity = null
    @selectionRadius = 20
    @highlightColor = "#4f545c"
    @bounds = (particle) ->
      #particle.pos.y = 0 if particle.pos.y > @height - 1
      ##log @height
      ##log particle.pos.y
      particle.pos.y = 0 if particle.pos.y < 0
      particle.pos.y = @height - 1  if particle.pos.y > @height - 1
      particle.pos.x = 0  if particle.pos.x < 0
      particle.pos.x = @width - 1  if particle.pos.x > @width - 1
    _this = this
    @collision = (composite) ->
      ##log composite
      #particles = composite.particles
      #compositePoints = for i of particles
      #  new Point(particles[i].pos.x,particles[i].pos.y)
      #polygon = new Polygon(compositePoints)
      #polygon.simple_polygon()
      #sweepLine = new SweepLine(polygon)
      #eventQueue = new EventQueue(polygon)

      #Add events to the sweepLine for detection
      #sweepLine.add ev while ev = eventQueue.events.pop()
      #log sweepLine

      #log sweepLine
      ##log eventQueue
      ##log composite.particles[0].pos
      ##log 'Checking for collisions'
      #if particle.pos.x
      #for c in @composites
      #  particles = @composites[c].particles
      #  compositePoints = for i in particles
      #    new Point(particles[i].pos.x,particles[i].pos.y)
      #  #log compositePoints
      #  polygon = new Polygon(compositePoints)
      #  sweepLine = new SweepLine(polygon)
      #  eventQueue = new EventQueue(polygon)
    #prevent context menu
    @canvas.oncontextmenu = (e) ->
      e.preventDefault()
    @canvas.onmousedown = (e) ->
      _this.mouse.x = e.layerX
      _this.mouse.y = e.layerY
      _this.mouseDown = true
      #log _this.mouse.x
      #log _this.mouse.y
      nearest = _this.nearestEntity()
      _this.draggedEntity = nearest if nearest
    @canvas.onmouseup = (e) ->
    # #log 'Mouseup fired!'
      _this.mouse.x = e.layerX
      _this.mouse.y = e.layerY
      _this.mouseDown = false
      _this.draggedEntity = null
    @canvas.onmousemove = (e) ->
      ##log _this.mouse.x
      ##log _this.mouse.y
      rect = _this.canvas.getBoundingClientRect()
      #_this.mouse.x = e.clientX - rect.left
      #_this.mouse.y = e.clientY - rect.top
      ##log e.clientX
      ##log e.layerX
      #_this.mouse.x = e.clientX - rect.left
      #_this.mouse.y = e.clientY - rect.top
      _this.mouse.x = e.layerX
      _this.mouse.y = e.layerY
    # #log e.layerY

      #Draw Mouse
    # canvas = document.querySelector('#canvas')
    # @ctx = canvas.getContext("2d")
    # @ctx.beginPath()
    # @ctx.beginPath()
    # @ctx.arc e.layerX, e.layerY, 2, 0, 2 * Math.PI
    # @ctx.fillStyle = "#ff0000"
    # @ctx.fill()
      ##log 'Drawing..'
      ##log canvas
      ##log @ctx

      ##log 'mouse ' + _this.mouse.x
      #if _this.nearestEntity()
        ##log 'layerX ' + e.layerX
        ##log 'entity ' + _this.nearestEntity().pos.x
    #simulation params
    @gravity = new Vec2(0, 0.2)
    @friction = 0.99
    @groundFriction = 0.8
    #holds composite entities
    @composites = []
  frame: (step) ->
    i = undefined
    j = undefined
    c = undefined
    for c of @composites
      for i of @composites[c].particles
        particles = @composites[c].particles
        #calculate velocity
        velocity = particles[i].pos.sub(particles[i].lastPos).scale(@friction)
        #ground friction
        if particles[i].pos.y >= @height - 1 and velocity.length2() > 0.000001
          m = velocity.length()
          velocity.x /= m
          velocity.y /= m
          velocity.mutableScale m * @groundFriction
        #save last good state
        particles[i].lastPos.mutableSet particles[i].pos
        #gravity
        particles[i].pos.mutableAdd @gravity
        #inertia
        particles[i].pos.mutableAdd velocity
    #handle dragging of entities
    @draggedEntity.pos.mutableSet @mouse  if @draggedEntity
    #relax
    stepCoef = 1 / step
    for c of @composites
      constraints = @composites[c].constraints
      i = 0
      while i < step
        for j of constraints
          constraints[j].relax stepCoef
        ++i
    #bounds checking
    for c of @composites
      particles = @composites[c].particles
      for i of particles
        @bounds particles[i]
    #collision checking
    for c of @composites
      @collision @composites[c]
  draw: ->
    i = undefined
    c = undefined
    @ctx.clearRect 0, 0, @canvas.width, @canvas.height
    for c of @composites
      #draw constraints
      if @composites[c].drawConstraints
        @composites[c].drawConstraints @ctx, @composites[c]
      else
        constraints = @composites[c].constraints
        for i of constraints
          constraints[i].draw @ctx
      #draw particles
      if @composites[c].drawParticles
        @composites[c].drawParticles @ctx, @composites[c]
      else
        particles = @composites[c].particles
        for i of particles
          particles[i].draw @ctx
    #highlight nearest / dragged entity
    nearest = @draggedEntity or @nearestEntity()
    if nearest
      ##log nearest
      @ctx.beginPath()
      for i of nearest.particles
        @ctx.arc nearest.particles[i].pos.x, nearest.particles[i].pos.y, 8, 0, 2 * Math.PI
      @ctx.strokeStyle = @highlightColor
      @ctx.stroke()
  nearestEntity: ->
    c = undefined
    i = undefined
    d2Nearest = 0
    entity = null
    constraintsNearest = null
    #find nearest entity
    for c of @composites
      ##log @mouse
      particles = @composites[c].particles
      ##log particles[0].pos
      if @mouse.x > particles[0].pos.x and @mouse.y > particles[0].pos.y and @mouse.x < particles[1].pos.x and @mouse.y > particles[1].pos.y and @mouse.x < particles[2].pos.x and @mouse.y < particles[2].pos.y and @mouse.x > particles[3].pos.x and @mouse.y < particles[3].pos.y
        log 'Within bounds'
    #find nearest point
    for c of @composites
      ##log @mouse
      #if @mouse
      particles = @composites[c].particles
      for i of particles
        d2 = particles[i].pos.dist2(@mouse)
        if d2 <= @selectionRadius * @selectionRadius and (not entity? or d2 < d2Nearest)
          entity = particles[i]
          constraintsNearest = @composites[c].constraints
          d2Nearest = d2
    #search for pinned constraints for this entity
    for i of constraintsNearest
      entity = constraintsNearest[i]  if constraintsNearest[i] instanceof PinConstraint and constraintsNearest[i].a is entity
    entity

  #OBJECTS
  #generic verlet entities
  point: (pos) ->
    composite = new Composite()
    composite.particles.push new Particle(pos)
    @composites.push composite
    composite
  lineSegments: (vertices, stiffness) ->
    i = undefined
    composite = new Composite()
    for i of vertices
      composite.particles.push new Particle(vertices[i])
      composite.constraints.push new DistanceConstraint(composite.particles[i], composite.particles[i - 1], stiffness)  if i > 0
    @composites.push composite
    composite
  cloth: (origin, width, height, segments, pinMod, stiffness) ->
    composite = new Composite()
    xStride = width / segments
    yStride = height / segments
    x = undefined
    y = undefined
    y = 0
    while y < segments
      x = 0
      while x < segments
        px = origin.x + x * xStride - width / 2 + xStride / 2
        py = origin.y + y * yStride - height / 2 + yStride / 2
        composite.particles.push new Particle(new Vec2(px, py))
        composite.constraints.push new DistanceConstraint(composite.particles[y * segments + x], composite.particles[y * segments + x - 1], stiffness)  if x > 0
        composite.constraints.push new DistanceConstraint(composite.particles[y * segments + x], composite.particles[(y - 1) * segments + x], stiffness)  if y > 0
        ++x
      ++y
    x = 0
    while x < segments
      composite.pin x  if x % pinMod is 0
      ++x
    @composites.push composite
    composite
  tire: (origin, radius, segments, spokeStiffness, treadStiffness) ->
    #log 'tire origin: ' + origin
    stride = (2 * Math.PI) / segments
    i = undefined
    composite = new Composite()
    #particles
    i = 0
    while i < segments
      theta = i * stride
      composite.particles.push new Particle(new Vec2(origin.x + Math.cos(theta) * radius, origin.y + Math.sin(theta) * radius))
      ++i
    log origin
    center = new Particle(origin)
    composite.particles.push center
    #constraints
    i = 0
    while i < segments
      #composite.constraints.push new DistanceConstraint(composite.particles[i], composite.particles[(i + 1) % segments], treadStiffness)
      composite.constraints.push new DistanceConstraint(composite.particles[i], center, spokeStiffness)
      #composite.constraints.push new DistanceConstraint(composite.particles[i], composite.particles[(i + 5) % segments], treadStiffness)
      ++i
    @composites.push composite
    composite
  rect: (origin, size, stiffness) ->
    log 'origin.x:  ' + origin.x
    log 'origin.y:  ' + origin.y
    #log 'size.x:    ' + size.x
    #log 'size.y:    ' + size.y
    #log 'stiffness: ' + stiffness

    #Create the edges
    composite = new Composite()
    #Center
    composite.particles.push new Particle(new Vec2(origin.x,origin.y))
    #Rect - Top Edge
    composite.particles.push new Particle(new Vec2(origin.x,origin.y))
    #Rect - Right Edge
    composite.particles.push new Particle(new Vec2(origin.x + size.x,origin.y))
    #Rect - Bottom Edge
    composite.particles.push new Particle(new Vec2(origin.x + size.x,origin.y + size.y))
    #Rect - Left Edge
    composite.particles.push new Particle(new Vec2(origin.x,origin.y + size.y))

    #Edge Constraints
    #composite.constraints.push new DistanceConstraint(composite.particles[0], composite.particles[1], stiffness)
    #composite.constraints.push new DistanceConstraint(composite.particles[1], composite.particles[2], stiffness)
    #composite.constraints.push new DistanceConstraint(composite.particles[2], composite.particles[3], stiffness)
    #composite.constraints.push new DistanceConstraint(composite.particles[3], composite.particles[0], stiffness)
    #Structural Supports - So the rect won't fall over!
    #composite.constraints.push new DistanceConstraint(composite.particles[0], composite.particles[2], stiffness)
    #composite.constraints.push new DistanceConstraint(composite.particles[1], composite.particles[3], stiffness)
    #The center!
    composite.constraints.push new DistanceConstraint(composite.particles[1], composite.particles[0], stiffness)
    #composite.constraints.push new DistanceConstraint(composite.particles[1], center, stiffness)
    #composite.constraints.push new DistanceConstraint(composite.particles[2], center, stiffness)
    #composite.constraints.push new DistanceConstraint(composite.particles[3], center, stiffness)

    #Output the composite
    @composites.push composite
    composite

###COLLISION DETECTION###
class @Point
  constructor: (x, y) ->
    @x = x
    @y = y
    #log '@Point'
  # Determines the xy lexicographical order of two points
  compare: (other_point) ->
    #log '@Point.compare'
    # x-coord first
    return 1  if @x > other_point.x
    return -1  if @x < other_point.x
    # y-coord second
    return 1  if @y > other_point.y
    return -1  if @y < other_point.y
    # they are the same point
    0
  # tests if point is Left|On|Right of the line P0 to P1.
  #
  # returns:
  #  >0 for left of the line
  #  0 for on the line
  #  <0 for right of the line
  is_left: (p0, p1) ->
    #log '@Point.is_left'
    (p1.x - p0.x) * (@y - p0.y) - (@x - p0.x) * (p1.y - p0.y)

#Convert point arrays into a polygon
class @Polygon
  constructor: (point_array) ->
    @vertices = point_array
    #log '@Polygon'
  #Tests polygon simplicity.
  #returns true if simple, false if not.
  simple_polygon: ->
    #log '@Polygon.simple_polygon'
    #log this
    event_queue = new EventQueue(this)
    sweep_line = new SweepLine(this)
    #This loop processes all events in the sorted queue
    #Events are only left or right vertices
    while e = event_queue.events.shift()
      #log 'In while'
      if e.type is "left"
        #log 'e.type is left'
        #log 'e'
        #log e
        s = sweep_line.add(e)
        log '======================================================'
        log 'ABOUT TO CHECK INTERSECTS IN SIMPLE_POLYGON!!'
        log 's'
        log s
        log 's.above'
        log s.above
        log 's.below'
        log s.below
        ####WHERE IS S.ABOVE AND S.BELOW CREATED?
        if sweep_line.intersect(s, s.above)
          log 'Intersects up'
          return false
        if sweep_line.intersect(s, s.below)
          log 'Intersects below'
          return false
      else
        s = sweep_line.find(e)
        if sweep_line.intersect(s.above, s.below)
          #log 'I don\'t even know'
          log 'Intersects above and below'
          return false
        sweep_line.remove s
    true

#Memoization of edges to process
class @EventQueue
  constructor: (polygon) ->
    #log '@EventQueue'
    individual_vertices = polygon.vertices.length - 1 #last vertex in geojson is equal to first vertex
    @number_of_events = 2 * (individual_vertices) #2 per edge - last event looping back to 0 is handled by +1 below
    @events = []
    #build up 2 'events' per edge. One for left vertex, one for right.
    i = 0
    while i < individual_vertices
      a = 2 * i
      b = 2 * i + 1
      @events[a] = edge: i
      @events[b] = edge: i
      @events[a].vertex = polygon.vertices[i]
      @events[b].vertex = polygon.vertices[i + 1]
      if @events[a].vertex.compare(@events[b].vertex) < 0
        @events[a].type = "left"
        @events[b].type = "right"
      else
        @events[a].type = "right"
        @events[b].type = "left"
      i++
    #sort events lexicographically
    @events.sort (a, b) ->
      a.vertex.compare b.vertex

###constructor###
class @RedBlackNode
  constructor: (value) ->
    #log '@RedBlackNode'
    #log value
    @_left = null
    @_right = null
    @_value = value
    @_height = 1
    @VERSION = 1.0
  ###add###
  add: (value) ->
    #log '@RedBlackNode.add'
    relation = value.compare(@_value)
    addResult = undefined
    result = undefined
    newNode = undefined
    unless relation is 0
      if relation < 0
        if @_left?
          addResult = @_left.add(value)
          @_left = addResult[0]
          newNode = addResult[1]
        else
          newNode = @_left = new RedBlackNode(value)
      else if relation > 0
        if @_right?
          addResult = @_right.add(value)
          @_right = addResult[0]
          newNode = addResult[1]
        else
          newNode = @_right = new RedBlackNode(value)
      result = [@balanceTree(), newNode]
    else
      result = [this, this]
    result
  ###balanceTree###
  balanceTree: ->
    #log '@RedBlackNode.balanceTree'
    leftHeight = (if (@_left?) then @_left._height else 0)
    rightHeight = (if (@_right?) then @_right._height else 0)
    result = undefined
    if leftHeight > rightHeight + 1
      result = @swingRight()
    else if rightHeight > leftHeight + 1
      result = @swingLeft()
    else
      @setHeight()
      result = this
    result
  ###join###
  join: (that) ->
    #log '@RedBlackNode.join'
    result = undefined
    unless that?
      result = this
    else
      top = undefined
      if @_height > that._height
        top = this
        top._right = that.join(top._right)
      else
        top = that
        top._left = @join(top._left)
      result = top.balanceTree()
    result
  ###moveLeft###
  moveLeft: ->
    #log '@RedBlackNode.moveLeft'
    right = @_right
    rightLeft = right._left
    @_right = rightLeft
    right._left = this
    @setHeight()
    right.setHeight()
    right
  ###moveRight###
  moveRight: ->
    #log '@RedBlackNode.moveRight'
    left = @_left
    leftRight = left._right
    @_left = leftRight
    left._right = this
    @setHeight()
    left.setHeight()
    left
  ###remove###
  remove: (value) ->
    #log '@RedBlackNode.remove'
    relation = value.compare(@_value)
    remResult = undefined
    result = undefined
    remNode = undefined
    unless relation is 0
      if relation < 0
        if @_left?
          remResult = @_left.remove(value)
          @_left = remResult[0]
          remNode = remResult[1]
        else
          remNode = null
      else
        if @_right?
          remResult = @_right.remove(value)
          @_right = remResult[0]
          remNode = remResult[1]
        else
          remNode = null
      result = this
    else
      remNode = this
      unless @_left?
        result = @_right
      else unless @_right?
        result = @_left
      else
        result = @_left.join(@_right)
        @_left = null
        @_right = null
    if remNode?
      if result?
        [result.balanceTree(), remNode]
      else
        [result, remNode]
    else
      [this, null]
  ###setHeight###
  setHeight: ->
    #log '@RedBlackNode.setHeight'
    leftHeight = (if (@_left?) then @_left._height else 0)
    rightHeight = (if (@_right?) then @_right._height else 0)
    @_height = (if (leftHeight < rightHeight) then rightHeight + 1 else leftHeight + 1)
  ###swingLeft###
  swingLeft: ->
    #log '@RedBlackNode.swingLeft'
    right = @_right
    rightLeft = right._left
    rightRight = right._right
    left = @_left
    leftHeight = (if (left?) then left._height else 0)
    rightLeftHeight = (if (rightLeft?) then rightLeft._height else 0)
    rightRightHeight = (if (rightRight?) then rightRight._height else 0)
    @_right = right.moveRight()  if rightLeftHeight > rightRightHeight
    @moveLeft()
  ###swingRight###
  swingRight: ->
    #log '@RedBlackNode.swingRight'
    left = @_left
    leftRight = left._right
    leftLeft = left._left
    right = @_right
    rightHeight = (if (right?) then right._height else 0)
    leftRightHeight = (if (leftRight?) then leftRight._height else 0)
    leftLeftHeight = (if (leftLeft?) then leftLeft._height else 0)
    @_left = left.moveLeft()  if leftRightHeight > leftLeftHeight
    @moveRight()
  ###traverse###
  traverse: (func) ->
    #log '@RedBlackNode.traverse'
    @_left.traverse func  if @_left?
    func this
    @_right.traverse func  if @_right?
  ###toString###
  toString: ->
    #log '@RedBlackNode.toString'
    @_value.toString()

###
RedBlackTree.js (actually an AVL)
copyright 2004, Kevin Lindsey
licensing info available at: http://www.kevlindev.com/license.txt
uses duck typing for comparator to determine left and rightedness.
added objects must implement a method called .order. eg. a.order(b);
.order should return:
-1 a <   b
0 a === b
1 a >   b
###
###constructor###
class @RedBlackTree
  constructor: ->
    #log '@RedBlackTree'
    @_root = null
    @_cursor = null
    @_ancestors = []
    @VERSION = 1.0
  ###private methods ****###
  ###_findNode###
  _findNode: (value, saveAncestors) ->
    #log '@RedBlackTree._findNode'
    saveAncestors = false  unless saveAncestors?
    result = @_root
    @_ancestors = []  if saveAncestors
    while result?
      relation = value.compare(result._value)
      unless relation is 0
        @_ancestors.push result  if saveAncestors
        if relation < 0
          result = result._left
        else
          result = result._right
      else
        break
    result
  ###_maxNode###
  _maxNode: (node, saveAncestors) ->
    #log '@RedBlackTree._maxNode'
    node = @_root  unless node?
    saveAncestors = false  unless saveAncestors?
    if node?
      while node._right?
        @_ancestors.push node  if saveAncestors
        node = node._right
    node
  ###_minNode###
  _minNode: (node, saveAncestors) ->
    #log '@RedBlackTree._minNode'
    node = @_root  unless node?
    saveAncestors = false  unless saveAncestors?
    if node?
      while node._left?
        @_ancestors.push node  if saveAncestors
        node = node._left
    node
  ###_nextNode###
  _nextNode: (node) ->
    #log '@RedBlackTree._nextNode'
    if node?
      if node._right?
        @_ancestors.push node
        node = @_minNode(node._right, true)
      else
        ancestors = @_ancestors
        parent = ancestors.pop()
        while parent? and parent._right is node
          node = parent
          parent = ancestors.pop()
        node = parent
    else
      @_ancestors = []
      node = @_minNode(@_root, true)
    node
  ###_previousNode###
  _previousNode: (node) ->
    #log '@RedBlackTree._previousNode'
    if node?
      if node._left?
        @_ancestors.push node
        node = @_maxNode(node._left, true)
      else
        ancestors = @_ancestors
        parent = ancestors.pop()
        while parent? and parent._left is node
          node = parent
          parent = ancestors.pop()
        node = parent
    else
      @_ancestors = []
      node = @_maxNode(@_root, true)
    node
  ###public methods###
  ###add###
  add: (value) ->
    #log '@RedBlackTree.add'
    result = undefined
    unless @_root?
      result = @_root = new RedBlackNode(value)
    else
      addResult = @_root.add(value)
      @_root = addResult[0]
      result = addResult[1]
    result
  ###find###
  find: (value) ->
    #log '@RedBlackTree.find'
    node = @_findNode(value)
    (if (node?) then node._value else null)
  ###findNext###
  findNext: (value) ->
    #log '@RedBlackTree.findNext'
    current = @_findNode(value, true)
    current = @_nextNode(current)
    (if (current?) then current._value else null)
  ###findPrevious###
  findPrevious: (value) ->
    #log '@RedBlackTree.findPrevious'
    current = @_findNode(value, true)
    current = @_previousNode(current)
    (if (current?) then current._value else null)
  ###max###
  max: ->
    #log '@RedBlackTree.max'
    result = @_maxNode()
    (if (result?) then result._value else null)
  ###min###
  min: ->
    #log '@RedBlackTree.min'
    result = @_minNode()
    (if (result?) then result._value else null)
  ###next###
  next: ->
    #log '@RedBlackTree.next'
    @_cursor = @_nextNode(@_cursor)
    (if (@_cursor) then @_cursor._value else null)
  ###previous###
  previous: ->
    #log '@RedBlackTree.previous'
    @_cursor = @_previousNode(@_cursor)
    (if (@_cursor) then @_cursor._value else null)
  ###remove###
  remove: (value) ->
    #log '@RedBlackTree.remove'
    result = undefined
    if @_root?
      remResult = @_root.remove(value)
      @_root = remResult[0]
      result = remResult[1]
    else
      result = null
    result
  ###traverse###
  traverse: (func) ->
    #log '@RedBlackTree.traverse'
    @_root.traverse func  if @_root?
  ###toString###
  toString: ->
    #log '@RedBlackTree.toString'
    lines = []
    if @_root?
      indentText = "  "
      stack = [[@_root, 0, "^"]]
      while stack.length > 0
        current = stack.pop()
        node = current[0]
        indent = current[1]
        line = ""
        i = 0
        while i < indent
          line += indentText
          i++
        line += current[2] + "(" + node.toString() + ")"
        lines.push line
        stack.push [node._right, indent + 1, "R"]  if node._right?
        stack.push [node._left, indent + 1, "L"]  if node._left?
    lines.join "\n"

#S. Tokumine 18/04/2011
#Javascript port of http://softsurfer.com/Archive/algorithm_0108/algorithm_0108.htm
#The Intersections for a Set of 2D Segments, and Testing Simple Polygons
#Shamos-Hoey Algorithm implementation in Javascript
#A container class for segments (or edges) of the polygon to test
#Allows storage and retrieval from the Balanced Binary Tree
class @SweepLineSeg
  constructor: (ev) ->
    #log '@SweepLineSeg'
    #log 'ev'
    #log ev
    #log 'x: ' + ev.vertex.x
    #log 'y: ' + ev.vertex.y
    @edge = ev.edge
    @left_point
    @right_point
    @above
    @below
  #required comparator for binary tree storage. Sort by y axis of the
  #points where the segment crosses L (eg, the left point)
  compare: (sls) ->
    #log '@SweepLineSeg.compare'
    #log sls
    #log 'edge ' + @edge
    #log '@left_point.y ' + @left_point.y
    #log 'sls.left_point.y ' + sls.left_point.y
    if @left_point.y > sls.left_point.y
      #log '@left_point.y > sls.left_point.y'
      return 1
    if @left_point.y < sls.left_point.y
      #log '2'
      #log '@left_point.y < sls.left_point.y'
      return -1
    #log 'Exiting'
    return 0
  toString: ->
    #log '@SweepLineSeg.toString'
    "edge:" + @edge

#Main SweepLine class.
#For full details on the algorithm used, consult the C code here:
#http://softsurfer.com/Archive/algorithm_0108/algorithm_0108.htm
#
#This is a direct port of the above C to Javascript
class @SweepLine
  constructor: (polygon) ->
    ##log '@SweepLine'
    @tree = new RedBlackTree()
    ##log @tree
    @polygon = polygon
    #log '@SweepLine'
  #Add Algorithm 'event' (more like unit of analysis) to queue
  #Units are segments or distinct edges of the polygon.
  add: (ev) ->
    #log '@SweepLine.add'
    #log 'ev.edge ' + ev.edge
    #build up segment data
    seg = new SweepLineSeg(ev)
    #log seg
    #log seg.edge
    p1 = @polygon.vertices[seg.edge]
    p2 = @polygon.vertices[seg.edge + 1]
    #if it is being added, then it must be a LEFT edge event
    #but need to determine which endpoint is the left one first
    #log 'p1'
    #log p1
    #log 'p2'
    #log p2
    if p1.compare(p2) < 0
      #log 'p1.compare(p2) < 0'
      seg.left_point = p1
      seg.right_point = p2
    else
      #log 'p1.compare(p2) > 0'
      seg.left_point = p2
      seg.right_point = p1
    #Add node to tree and setup linkages to "above" and "below"
    #edges as per algorithm
    #log 'just before nd = @tree.add(seg)'
    #log seg
    nd = @tree.add(seg)
    #log 'nd'
    #log nd
    #log 'nd._value'
    #log nd._value
    nx = @tree.findNext(nd._value)
    np = @tree.findPrevious(nd._value)
    #log '@tree'
    #log @tree
    #log 'nx'
    #log nx
    #log 'np'
    #log np
    if nx
      #log 'nx active'
      seg.above = nx
      seg.above.below = seg
    if np
      #log 'np active'
      seg.below = np
      seg.below.above = seg
    seg
  find: (ev) ->
    #log '@SweepLine.find'
    #need a segment to find it in the tree
    #TODO: TIDY THIS UP!!!
    seg = new SweepLineSeg(ev)
    p1 = @polygon.vertices[seg.edge]
    p2 = @polygon.vertices[seg.edge + 1]
    #if it is being added, then it must be a LEFT edge event
    #but need to determine which endpoint is the left one first
    if p1.compare(p2) < 0
      seg.left_point = p1
      seg.right_point = p2
    else
      seg.left_point = p2
      seg.right_point = p1
    nd = @tree.find(seg)
    if nd
      nd
    else
      false #BUG: unsure what to return here. Probably not false.
  #When removing a node from the tree, ensure the above and below links are
  #passed on to adjacent nodes before node is deleted
  remove: (seg) ->
    #log '@SweepLine.remove'
    #Pretty sure there is a bug here as the tree isn't getting pruned correctly.
    #In fact, I thin the remove method is removing the wrong elements from the list.
    try
      nd = @tree.find(seg)
    catch err
      return
    nx = @tree.findNext(nd)
    nx.below = seg.below  if nx
    np = @tree.findPrevious(nd)
    np.above = seg.above  if np
    @tree.remove seg
  #test intersect of 2 segments and return: false=none, true=intersect
  intersect: (s1, s2) ->
    log '***************************************************'
    log 'Running Intersect'
    #log '@SweepLine.intersect'
    log 's1'
    log s1
    log 's2'
    log s2
    if not s1 or not s2 #no intersect if either segment doesn't exist
      #log 'no s1 or s2 exist'
      return false
    #check for consecutive edges in polygon
    e1 = s1.edge
    e2 = s2.edge
    if ((e1 + 1) % @polygon.vertices.length is e2) or (e1 is (e2 + 1) % @polygon.vertices.length) #no non-simple intersect since consecutive
      log 'no non-simple intersect since consecutive'
      return false
    #test for existence of an intersect point
    lsign = s2.left_point.is_left(s1.left_point, s1.right_point) #s2 left point sign
    rsign = s2.right_point.is_left(s1.left_point, s1.right_point) #s2 right point sign
    #s2 endpoints have same sign relative to s1
    if lsign * rsign > 0 #=> on same side => no intersect is possible
      log 'no intersect is possible'
      return false
    lsign = s1.left_point.is_left(s2.left_point, s2.right_point) #s1 left point sign
    rsign = s1.right_point.is_left(s2.left_point, s2.right_point) #s1 right point sign
    #s1 endpoints have same sign relative to s2
    if lsign * rsign > 0 #=> on same side => no intersect is possible
      log 'no intersect is possible'
      return false
    log 'EXITING'
    log '***************************************************'
    true
    if true #segments s1 and s2 straddle. Intersect exists.
      log 'INTERSECTING'
      log s1
      log s2
    else
      log 'Shit'